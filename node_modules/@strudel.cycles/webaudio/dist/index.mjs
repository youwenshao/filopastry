import * as M from "@strudel.cycles/core";
import { logger as Y, valueToMidi as ge, noteToMidi as oe, midiToFreq as de } from "@strudel.cycles/core";
import { map as ue } from "nanostores";
if (typeof DelayNode < "u") {
  class e extends DelayNode {
    constructor(t, o, i, c) {
      super(t), o = Math.abs(o), this.delayTime.value = i;
      const s = t.createGain();
      s.gain.value = Math.min(Math.abs(c), 0.995), this.feedback = s.gain;
      const a = t.createGain();
      return a.gain.value = o, this.delayGain = a, this.connect(s), this.connect(a), s.connect(this), this.connect = (r) => a.connect(r), this;
    }
    start(t) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, t + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(n, t, o) {
    return new e(this, n, t, o);
  };
}
typeof AudioContext < "u" && (AudioContext.prototype.impulseResponse = function(e, n = 1) {
  const t = this.sampleRate * e, o = this.createBuffer(n, t, this.sampleRate), i = o.getChannelData(0);
  for (let c = 0; c < t; c++)
    i[c] = (2 * Math.random() - 1) * Math.pow(1 - c / t, e);
  return o;
}, AudioContext.prototype.createReverb = function(e) {
  const n = this.createConvolver();
  return n.setDuration = (t) => (n.buffer = this.impulseResponse(t), n.duration = e, n), n.setDuration(e), n;
});
var $ = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] }
};
if (typeof GainNode < "u") {
  class e extends GainNode {
    constructor(t, o) {
      if (super(t), !$[o])
        throw new Error("vowel: unknown vowel " + o);
      const { gains: i, qs: c, freqs: s } = $[o], a = t.createGain();
      for (let r = 0; r < 5; r++) {
        const g = t.createGain();
        g.gain.value = i[r];
        const u = t.createBiquadFilter();
        u.type = "bandpass", u.Q.value = c[r], u.frequency.value = s[r], this.connect(u), u.connect(g), g.connect(a);
      }
      return a.gain.value = 8, this.connect = (r) => a.connect(r), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(n) {
    return new e(this, n);
  };
}
const le = "data:application/javascript;base64,Ly8gTElDRU5TRSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2My4wIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGt0cjAvV2ViRGlydC9ibG9iL21haW4vTElDRU5TRQovLyBhbGwgdGhlIGNyZWRpdCBnb2VzIHRvIGRrdHIwJ3Mgd2ViZGlydDogaHR0cHM6Ly9naXRodWIuY29tL2RrdHIwL1dlYkRpcnQvYmxvYi81Y2UzZDY5ODM2MmM1NGQ2ZTFiNjhhY2M0N2ViMjk1NWFjNjJjNzkzL2Rpc3QvQXVkaW9Xb3JrbGV0cy5qcwovLyA8MwoKY2xhc3MgQ29hcnNlUHJvY2Vzc29yIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHsKICBzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCkgewogICAgcmV0dXJuIFt7IG5hbWU6ICdjb2Fyc2UnLCBkZWZhdWx0VmFsdWU6IDEgfV07CiAgfQoKICBjb25zdHJ1Y3RvcigpIHsKICAgIHN1cGVyKCk7CiAgICB0aGlzLm5vdFN0YXJ0ZWQgPSB0cnVlOwogIH0KCiAgcHJvY2VzcyhpbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMpIHsKICAgIGNvbnN0IGlucHV0ID0gaW5wdXRzWzBdOwogICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1swXTsKICAgIGNvbnN0IGNvYXJzZSA9IHBhcmFtZXRlcnMuY29hcnNlOwogICAgY29uc3QgYmxvY2tTaXplID0gMTI4OwogICAgY29uc3QgaGFzSW5wdXQgPSAhKGlucHV0WzBdID09PSB1bmRlZmluZWQpOwogICAgaWYgKGhhc0lucHV0KSB7CiAgICAgIHRoaXMubm90U3RhcnRlZCA9IGZhbHNlOwogICAgICBvdXRwdXRbMF1bMF0gPSBpbnB1dFswXVswXTsKICAgICAgZm9yIChsZXQgbiA9IDE7IG4gPCBibG9ja1NpemU7IG4rKykgewogICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgb3V0cHV0Lmxlbmd0aDsgbysrKSB7CiAgICAgICAgICBvdXRwdXRbb11bbl0gPSBuICUgY29hcnNlID09IDAgPyBpbnB1dFswXVtuXSA6IG91dHB1dFtvXVtuIC0gMV07CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gdGhpcy5ub3RTdGFydGVkIHx8IGhhc0lucHV0OwogIH0KfQoKcmVnaXN0ZXJQcm9jZXNzb3IoJ2NvYXJzZS1wcm9jZXNzb3InLCBDb2Fyc2VQcm9jZXNzb3IpOwoKY2xhc3MgQ3J1c2hQcm9jZXNzb3IgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3IgewogIHN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKSB7CiAgICByZXR1cm4gW3sgbmFtZTogJ2NydXNoJywgZGVmYXVsdFZhbHVlOiAwIH1dOwogIH0KCiAgY29uc3RydWN0b3IoKSB7CiAgICBzdXBlcigpOwogICAgdGhpcy5ub3RTdGFydGVkID0gdHJ1ZTsKICB9CgogIHByb2Nlc3MoaW5wdXRzLCBvdXRwdXRzLCBwYXJhbWV0ZXJzKSB7CiAgICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTsKICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbMF07CiAgICBjb25zdCBjcnVzaCA9IHBhcmFtZXRlcnMuY3J1c2g7CiAgICBjb25zdCBibG9ja1NpemUgPSAxMjg7CiAgICBjb25zdCBoYXNJbnB1dCA9ICEoaW5wdXRbMF0gPT09IHVuZGVmaW5lZCk7CiAgICBpZiAoaGFzSW5wdXQpIHsKICAgICAgdGhpcy5ub3RTdGFydGVkID0gZmFsc2U7CiAgICAgIGlmIChjcnVzaC5sZW5ndGggPT09IDEpIHsKICAgICAgICBjb25zdCB4ID0gTWF0aC5wb3coMiwgY3J1c2hbMF0gLSAxKTsKICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGJsb2NrU2l6ZTsgbisrKSB7CiAgICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGgucm91bmQoaW5wdXRbMF1bbl0gKiB4KSAvIHg7CiAgICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG91dHB1dC5sZW5ndGg7IG8rKykgewogICAgICAgICAgICBvdXRwdXRbb11bbl0gPSB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBibG9ja1NpemU7IG4rKykgewogICAgICAgICAgbGV0IHggPSBNYXRoLnBvdygyLCBjcnVzaFtuXSAtIDEpOwogICAgICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKGlucHV0WzBdW25dICogeCkgLyB4OwogICAgICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBvdXRwdXQubGVuZ3RoOyBvKyspIHsKICAgICAgICAgICAgb3V0cHV0W29dW25dID0gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gdGhpcy5ub3RTdGFydGVkIHx8IGhhc0lucHV0OwogIH0KfQpyZWdpc3RlclByb2Nlc3NvcignY3J1c2gtcHJvY2Vzc29yJywgQ3J1c2hQcm9jZXNzb3IpOwoKY2xhc3MgU2hhcGVQcm9jZXNzb3IgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3IgewogIHN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKSB7CiAgICByZXR1cm4gW3sgbmFtZTogJ3NoYXBlJywgZGVmYXVsdFZhbHVlOiAwIH1dOwogIH0KCiAgY29uc3RydWN0b3IoKSB7CiAgICBzdXBlcigpOwogICAgdGhpcy5ub3RTdGFydGVkID0gdHJ1ZTsKICB9CgogIHByb2Nlc3MoaW5wdXRzLCBvdXRwdXRzLCBwYXJhbWV0ZXJzKSB7CiAgICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTsKICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbMF07CiAgICBjb25zdCBzaGFwZTAgPSBwYXJhbWV0ZXJzLnNoYXBlWzBdOwogICAgY29uc3Qgc2hhcGUxID0gc2hhcGUwIDwgMSA/IHNoYXBlMCA6IDEuMCAtIDRlLTEwOwogICAgY29uc3Qgc2hhcGUgPSAoMi4wICogc2hhcGUxKSAvICgxLjAgLSBzaGFwZTEpOwogICAgY29uc3QgYmxvY2tTaXplID0gMTI4OwogICAgY29uc3QgaGFzSW5wdXQgPSAhKGlucHV0WzBdID09PSB1bmRlZmluZWQpOwogICAgaWYgKGhhc0lucHV0KSB7CiAgICAgIHRoaXMubm90U3RhcnRlZCA9IGZhbHNlOwogICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGJsb2NrU2l6ZTsgbisrKSB7CiAgICAgICAgY29uc3QgdmFsdWUgPSAoKDEgKyBzaGFwZSkgKiBpbnB1dFswXVtuXSkgLyAoMSArIHNoYXBlICogTWF0aC5hYnMoaW5wdXRbMF1bbl0pKTsKICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG91dHB1dC5sZW5ndGg7IG8rKykgewogICAgICAgICAgb3V0cHV0W29dW25dID0gdmFsdWU7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gdGhpcy5ub3RTdGFydGVkIHx8IGhhc0lucHV0OwogIH0KfQoKcmVnaXN0ZXJQcm9jZXNzb3IoJ3NoYXBlLXByb2Nlc3NvcicsIFNoYXBlUHJvY2Vzc29yKTsK";
function k(e) {
  const n = I().createGain();
  return n.gain.value = e, n;
}
const Ie = ({ s: e, freq: n, t }) => {
  const o = I().createOscillator();
  return o.type = e || "triangle", o.frequency.value = Number(n), o.start(t), { node: o, stop: (c) => o.stop(c) };
}, ce = (e, n, t, o, i, c) => {
  const s = I().createGain();
  return s.gain.setValueAtTime(0, c), s.gain.linearRampToValueAtTime(i, c + e), s.gain.linearRampToValueAtTime(t * i, c + e + n), {
    node: s,
    stop: (a) => {
      s.gain.setValueAtTime(t * i, a), s.gain.linearRampToValueAtTime(0, a + o);
    }
  };
}, He = (e, n, t, o, i, c, s) => {
  const a = I().createGain();
  return a.gain.setValueAtTime(0, c), a.gain.linearRampToValueAtTime(i, c + e), a.gain.linearRampToValueAtTime(t * i, c + e + n), a.gain.setValueAtTime(t * i, s), a.gain.linearRampToValueAtTime(0, s + o), a;
}, J = (e, n, t) => {
  const o = I().createBiquadFilter();
  return o.type = e, o.frequency.value = n, o.Q.value = t, o;
}, { Pattern: Ce, logger: ie } = M, P = ue();
function ae(e, n, t = {}) {
  P.setKey(e, { onTrigger: n, data: t });
}
function _(e) {
  return P.get()[e];
}
const Te = () => P.set({});
let O;
const I = () => (O || (O = new AudioContext()), O);
let W;
const Q = () => {
  const e = I();
  return W || (W = e.createGain(), W.connect(e.destination)), W;
}, Ne = () => {
  Q().gain.linearRampToValueAtTime(0, I().currentTime + 0.01), W = null;
};
let D;
function fe() {
  return D || (D = I().audioWorklet.addModule(le), D);
}
function x(e, n, t) {
  const o = new AudioWorkletNode(e, n);
  return Object.entries(t).forEach(([i, c]) => {
    o.parameters.get(i).value = c;
  }), o;
}
async function Ae() {
  if (typeof window < "u")
    try {
      await I().resume(), await fe();
    } catch (e) {
      console.warn("could not load AudioWorklet effects coarse, crush and shape", e);
    }
}
async function We() {
  return new Promise((e) => {
    document.addEventListener("click", async function n() {
      await Ae(), e(), document.removeEventListener("click", n);
    });
  });
}
let G = {};
const ee = 0.98;
function he(e, n, t, o) {
  if (t > ee && ie(`delayfeedback was clamped to ${ee} to save your ears`), t = M.clamp(t, 0, 0.98), !G[e]) {
    const c = I().createFeedbackDelay(1, n, t);
    c.start?.(o), c.connect(Q()), G[e] = c;
  }
  return G[e].delayTime.value !== n && G[e].delayTime.setValueAtTime(n, o), G[e].feedback.value !== t && G[e].feedback.setValueAtTime(t, o), G[e];
}
let w = {};
function pe(e, n = 2) {
  if (!w[e]) {
    const o = I().createReverb(n);
    o.connect(Q()), w[e] = o;
  }
  return w[e].duration !== n && (w[e] = w[e].setDuration(n), w[e].duration = n), w[e];
}
function ne(e, n, t) {
  const o = k(t);
  return e.connect(o), o.connect(n), o;
}
const se = async (e, n, t, o) => {
  const i = I();
  e.ensureObjectValue();
  let c = i.currentTime + n, {
    s = "triangle",
    bank: a,
    source: r,
    gain: g = 0.8,
    // low pass
    cutoff: u,
    resonance: p = 1,
    // high pass
    hcutoff: f,
    hresonance: b = 1,
    // band pass
    bandf: A,
    bandq: B = 1,
    //
    coarse: C,
    crush: m,
    shape: H,
    pan: K,
    vowel: S,
    delay: T = 0,
    delayfeedback: X = 0.5,
    delaytime: l = 0.25,
    orbit: z = 1,
    room: F,
    size: V = 2
  } = e.value;
  const { velocity: j = 1 } = e.context;
  g *= j;
  let R = [];
  const U = () => {
    R.forEach((h) => h?.disconnect());
  };
  a && s && (s = `${a}_${s}`);
  let y;
  if (r)
    y = r(c, e.value, t);
  else if (_(s)) {
    const { onTrigger: h } = _(s), N = await h(c, e.value, U);
    N && (y = N.node, N.stop(c + t));
  } else
    throw new Error(`sound ${s} not found! Is it loaded?`);
  if (!y)
    return;
  if (i.currentTime > c) {
    ie("[webaudio] skip hap: still loading", i.currentTime - c);
    return;
  }
  const d = [];
  if (d.push(y), d.push(k(g)), u !== void 0 && d.push(J("lowpass", u, p)), f !== void 0 && d.push(J("highpass", f, b)), A !== void 0 && d.push(J("bandpass", A, B)), S !== void 0 && d.push(i.createVowelFilter(S)), C !== void 0 && d.push(x(i, "coarse-processor", { coarse: C })), m !== void 0 && d.push(x(i, "crush-processor", { crush: m })), H !== void 0 && d.push(x(i, "shape-processor", { shape: H })), K !== void 0) {
    const h = i.createStereoPanner();
    h.pan.value = 2 * K - 1, d.push(h);
  }
  const Z = k(1);
  d.push(Z), Z.connect(Q());
  let v;
  if (T > 0 && l > 0 && X > 0) {
    const h = he(z, l, X, c);
    v = ne(Z, h, T);
  }
  let q;
  if (F > 0 && V > 0) {
    const h = pe(z, V);
    q = ne(Z, h, F);
  }
  d.slice(1).reduce((h, N) => h.connect(N), d[0]), R = d.concat([v, q]);
}, Be = (e, n, t, o) => se(n, e - t, n.duration / o);
Ce.prototype.webaudio = function() {
  return this.onTrigger(Be);
};
function Ye(e = {}) {
  e = {
    getTime: () => I().currentTime,
    defaultOutput: se,
    ...e
  };
  const { defaultOutput: n, getTime: t } = e;
  return new M.Cyclist({
    ...e,
    onTrigger: M.getTrigger({ defaultOutput: n, getTime: t })
  });
}
const E = {}, L = {}, Ke = (e) => E[e];
function be(e, n) {
  var t = n ? 1e3 : 1024;
  if (e < t)
    return e + " B";
  var o = n ? ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] : ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], i = -1;
  do
    e /= t, ++i;
  while (e >= t);
  return e.toFixed(1) + " " + o[i];
}
const me = async (e, n, t, o, i, c, s) => {
  let a = 0;
  i !== void 0 && t !== void 0 && Y("[sampler] hap has note and freq. ignoring note", "warning");
  let r = ge({ freq: i, note: t }, 36);
  a = r - 36;
  const g = I();
  let u;
  if (Array.isArray(c))
    u = c[n % c.length];
  else {
    const A = (C) => oe(C) - r, B = Object.keys(c).filter((C) => !C.startsWith("_")).reduce(
      (C, m, H) => !C || Math.abs(A(m)) < Math.abs(A(C)) ? m : C,
      null
    );
    a = -A(B), u = c[B][n % c[B].length];
  }
  s && (u = await s(u));
  let p = await ye(u, g, e, n);
  o < 0 && (p = Ge(p));
  const f = g.createBufferSource();
  f.buffer = p;
  const b = 1 * Math.pow(2, a / 12);
  return f.playbackRate.value = b, f;
}, ye = (e, n, t, o = 0) => {
  const i = t ? `sound "${t}:${o}"` : "sample";
  if (!L[e]) {
    Y(`[sampler] load ${i}..`, "load-sample", { url: e });
    const c = Date.now();
    L[e] = fetch(e).then((s) => s.arrayBuffer()).then(async (s) => {
      const a = Date.now() - c, r = be(s.byteLength);
      Y(`[sampler] load ${i}... done! loaded ${r} in ${a}ms`, "loaded-sample", { url: e });
      const g = await n.decodeAudioData(s);
      return E[e] = g, g;
    });
  }
  return L[e];
};
function Ge(e) {
  const n = I(), t = n.createBuffer(e.numberOfChannels, e.length, n.sampleRate);
  for (let o = 0; o < e.numberOfChannels; o++)
    t.copyToChannel(e.getChannelData(o).slice().reverse(), o, o);
  return t;
}
const Se = (e) => E[e], we = (e, n, t = e._base || "") => Object.entries(e).forEach(([o, i]) => {
  if (typeof i == "string" && (i = [i]), typeof i != "object")
    throw new Error("wrong sample map format for " + o);
  t = i._base || t;
  const c = (s) => (t + s).replace("github:", "https://raw.githubusercontent.com/");
  Array.isArray(i) ? i = i.map(c) : i = Object.fromEntries(
    Object.entries(i).map(([s, a]) => [s, (typeof a == "string" ? [a] : a).map(c)])
  ), n(o, i);
});
let re = {};
function ze(e, n) {
  re[e] = n;
}
function Xe(e) {
  const n = Object.entries(re).find(([t]) => e.startsWith(t));
  if (n)
    return n[1];
}
const Ve = async (e, n = e._base || "", t = {}) => {
  if (typeof e == "string") {
    const c = Xe(e);
    if (c)
      return c(e);
    if (e.startsWith("github:")) {
      let [a, r] = e.split("github:");
      r = r.endsWith("/") ? r.slice(0, -1) : r, e = `https://raw.githubusercontent.com/${r}/strudel.json`;
    }
    if (typeof fetch != "function")
      return;
    const s = e.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(e).then((a) => a.json()).then((a) => Ve(a, n || a._base || s, t)).catch((a) => {
      throw console.error(a), new Error(`error loading "${e}"`);
    });
  }
  const { prebake: o, tag: i } = t;
  we(
    e,
    (c, s) => ae(c, (a, r, g) => Re(a, r, g, s), {
      type: "sample",
      samples: s,
      baseUrl: n,
      prebake: o,
      tag: i
    }),
    n
  );
}, te = [];
async function Re(e, n, t, o, i) {
  const {
    s: c,
    freq: s,
    unit: a,
    nudge: r = 0,
    // TODO: is this in seconds?
    cut: g,
    loop: u,
    clip: p = void 0,
    // if 1, samples will be cut off when the hap ends
    n: f = 0,
    note: b,
    speed: A = 1,
    // sample playback speed
    begin: B = 0,
    end: C = 1
  } = n;
  if (A === 0)
    return;
  const m = I(), { attack: H = 1e-3, decay: K = 1e-3, sustain: S = 1, release: T = 1e-3 } = n, X = e + r, l = await me(c, f, b, A, s, o, i);
  if (m.currentTime > e) {
    Y(`[sampler] still loading sound "${c}:${f}"`, "highlight");
    return;
  }
  if (!l) {
    Y(`[sampler] could not load "${c}:${f}"`, "error");
    return;
  }
  l.playbackRate.value = Math.abs(A) * l.playbackRate.value, a === "c" && (l.playbackRate.value = l.playbackRate.value * l.buffer.duration * 1);
  const z = B * l.buffer.duration;
  l.start(X, z);
  const F = l.buffer.duration / l.playbackRate.value, { node: V, stop: j } = ce(H, K, S, T, 1, e);
  l.connect(V);
  const R = m.createGain();
  V.connect(R), l.onended = function() {
    l.disconnect(), V.disconnect(), R.disconnect(), t();
  };
  const y = { node: R, bufferSource: l, stop: (d, Z = p === void 0) => {
    let v = d;
    Z && (v = e + (C - B) * F), l.stop(v + T), j(v);
  } };
  if (g !== void 0) {
    const d = te[g];
    d && (d.node.gain.setValueAtTime(1, X), d.node.gain.linearRampToValueAtTime(0, X + 0.01)), te[g] = y;
  }
  return y;
}
function Fe() {
  ["sine", "square", "triangle", "sawtooth"].forEach((e) => {
    ae(
      e,
      (n, t, o) => {
        const { attack: i = 1e-3, decay: c = 0.05, sustain: s = 0.6, release: a = 0.01 } = t;
        let { n: r, note: g, freq: u } = t;
        r = g || r || 36, typeof r == "string" && (r = oe(r)), !u && typeof r == "number" && (u = de(r));
        const { node: p, stop: f } = Ie({ t: n, s: e, freq: u }), b = k(0.3), { node: A, stop: B } = ce(i, c, s, a, 1, n);
        return p.onended = () => {
          p.disconnect(), b.disconnect(), o();
        }, {
          node: p.connect(b).connect(A),
          stop: (C) => {
            B(C), f(C + a);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
export {
  k as gainNode,
  He as getADSR,
  I as getAudioContext,
  Ke as getCachedBuffer,
  ce as getEnvelope,
  J as getFilter,
  Se as getLoadedBuffer,
  Ie as getOscillator,
  me as getSampleBufferSource,
  _ as getSound,
  Ae as initAudio,
  We as initAudioOnFirstClick,
  ye as loadBuffer,
  Re as onTriggerSample,
  Ne as panic,
  we as processSampleMap,
  ze as registerSamplesPrefix,
  ae as registerSound,
  Fe as registerSynthSounds,
  Te as resetLoadedSounds,
  Ge as reverseBuffer,
  Ve as samples,
  P as soundMap,
  se as webaudioOutput,
  Be as webaudioOutputTrigger,
  Ye as webaudioScheduler
};
